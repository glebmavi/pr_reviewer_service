# Сервис назначения ревьюеров для Pull Request’ов

`pr_reviewer_service` — это Go-микросервис, предоставляющий HTTP API для управления командами, пользователями и процессом назначения ревьюеров на Pull Request'ы (PR).

Сервис выполняет следующие задачи:
- Управление командами и их составом.
- Управление активностью пользователей.
- Автоматическое назначение до 2-х ревьюеров при создании PR.
- Переназначение ревьюеров.
- Запрет на изменение `MERGED` PR.
- Массовая деактивация команды и безопасное переназначение открытых ревью.
- Сбор статистики по ревью.

## Технологический стек

| Компонент          | Технология   |
|--------------------|--------------|
| Язык               | Golang       |
| База Данных        | PostgreSQL   |
| HTTP Роутер        | Chi          |
| DB Драйвер         | pgx/v5       |
| Генерация DB-слоя  | sqlc         |
| Генерация API-слоя | oapi-codegen |

## Запуск

Для запуска проекта необходимы **Docker** и **Docker Compose**.

### Первоначальная настройка

1.  Скопируйте файл `.env.example` в `.env` и измените переменные окружения.

### Основные команды

*   **Запуск приложения**

    Выполните команду:
    ```sh
    make up
    ```
    Эта команда соберет docker-образ приложения, поднимет контейнеры с PostgreSQL и самим сервисом, а также автоматически применит миграции базы данных. Сервис будет доступен на порту, указанном в `.env` (по умолчанию `8080`).

*   **Остановка приложения**
    ```sh
    make down
    ```

*   **Запуск E2E-тестов**
    ```sh
    make test
    ```

*   **Запуск линтера**
    ```sh
    make lint
    ```

*   **Генерация кода**

    После изменения `openapi.yml` или SQL-запросов в `db/sql/` необходимо выполнить кодогенерацию:
    ```sh
    make generate
    ```

## Конфигурация линтера

Был выбран `golangci-lint`. Конфигурация в файле `.golangci.yml` решает следующие задачи:

**Линтеры:**

- `revive`: для проверки стиля и качества кода (улучшенная версия `golint`).
- `gocyclo`: для контроля цикломатической сложности функций. Установлен порог `15`, чтобы предотвратить написание слишком сложных и трудноподдерживаемых функций.
- `errcheck`: для проверки того, что все возвращаемые ошибки обрабатываются.
- `staticcheck` и `unused`: для поиска неиспользуемого кода и других статических ошибок.
- `ineffassign`: для поиска бесполезных присваиваний.
- `govet`: стандартный анализатор Go для поиска подозрительных конструкций.

**Исключения:**

- Отключены проверки для автоматически сгенерированного кода (`pkg/api/`, `internal/storage/postgres/models/`), так как мы не контролируем его напрямую. 
- Отключены некоторые правила `revive` (например, `package-comments` и `exported`), чтобы не загромождать код избыточными комментариями, не требующимися в рамках задачи.

**Форматтеры:**

- Включены `gofmt` и `goimports` для автоматического форматирования кода и организации импортов.


## Ход решения

В ходе работы над проектом возникло несколько вопросов, требующих принятия самостоятельных решений, как и предлагалось в задании.

### 1. Расширение API для реализации дополнительного функционала

Исходная спецификация `task/openapi.yml` не содержала эндпоинтов для реализации дополнительных заданий (статистика, массовая деактивация) и некоторых полезных CRUD-операций.

Для этого, спецификация была расширена. Ключевые отличия `openapi.yml` от оригинала:

*   **Добавлены эндпоинты для статистики** (доп. задание):
    *   `GET /stats`: общая статистика по количеству ревью для каждого пользователя.
    *   `GET /stats/team/{team_name}/open-review-count`: количество открытых ревью у команды.
    *   `GET /stats/team/{team_name}/merged-review-count`: количество закрытых ревью у команды.
    *   `GET /stats/user/{user_id}/open-review-count`: количество открытых ревью у пользователя.
    *   `GET /stats/user/{user_id}/merged-review-count`: количество закрытых ревью у пользователя.

*   **Добавлены эндпоинты для управления командами и пользователями**:
    *   `POST /team/deactivate`: массовая деактивация команды и переназначение ревью (доп. задание).
    *   `POST /team/edit`: изменение имени команды.
    *   `POST /users/add`, `POST /users/edit`, `POST /users/moveToTeam`: более гранулярное управление пользователями.

*   **Добавлен эндпоинт для поиска проблемных PR**:
    *   `GET /pullRequest/open-without-reviewers`: получение списка открытых PR без назначенных ревьюеров.

*   **Изменены существующие эндпоинты**:
    *   В `POST /pullRequest/create` убрано поле `pull_request_id` из тела запроса. ID генерируется сервисом, а не клиентом.
    *   В `POST /team/add` в модели `TeamMember` поле `is_active` сделано необязательным и по умолчанию `true`.

### 2. Проработка логики и пограничных случаев

В процессе реализации основной и дополнительной функциональности возникли вопросы, требующие уточнения логики. Были приняты следующие решения:

**Логика назначения ревьюеров:**

Согласно заданию: "Если доступных кандидатов меньше двух, назначается доступное количество (0/1)". Таким образом при любом переназначении (например, при деактивации пользователя) система стремится сохранить двух ревьюеров, но если после поиска PR остается только один ревьюер или без ревьюверов, то это считается допустимым состоянием.

**Деактивация команды (дополнительное задание):**

Процесс деактивации устанавливает флаг `isActive = false` как для самой команды, так и для всех ее участников. Удаление сущностей не происходит. 

Система находит все открытые PR, где ревьюерами были пользователи из деактивированной команды, и удаляет их из списка ревьюеров.

Если в результате PR остается без ревьюеров, запускается процесс поиска до двух новых случайных и активных ревьюеров из команды автора PR (при условии, что команда автора не была деактивирована). Если найти новых ревьюеров не удается, PR остается без них.

**Деактивация пользователя:**

По аналогии с командами, пользователи не удаляются, а только деактивируются.

При деактивации пользователя система проверяет его открытые PR. Если после его снятия с ревью у PR не остается других ревьюеров, запускается поиск новых кандидатов (до 2-х) в той же команде. Если у PR остается хотя бы один ревьюер, переназначение не происходит.

**Перемещение пользователей между командами:**

Операция перемещения доступна только для активных пользователей.

Перемещать пользователя можно только в активную команду из активной команды. Для выполнения операции над неактивными сущностями их необходимо сначала активировать вручную.

