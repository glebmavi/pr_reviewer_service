// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: pr.sql

package models

import (
	"context"
)

const addReviewerToPR = `-- name: AddReviewerToPR :exec
INSERT INTO review_assignments (pr_id, user_id)
VALUES ($1, $2)
`

type AddReviewerToPRParams struct {
	PrID   string
	UserID string
}

func (q *Queries) AddReviewerToPR(ctx context.Context, arg AddReviewerToPRParams) error {
	_, err := q.db.Exec(ctx, addReviewerToPR, arg.PrID, arg.UserID)
	return err
}

const countMergedReviewsByTeam = `-- name: CountMergedReviewsByTeam :one
SELECT COUNT(pr.pr_id)
FROM pull_requests pr
JOIN review_assignments ra ON pr.pr_id = ra.pr_id
JOIN users u ON ra.user_id = u.user_id
WHERE u.team_id = $1 AND pr.status = 'MERGED'
`

func (q *Queries) CountMergedReviewsByTeam(ctx context.Context, teamID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countMergedReviewsByTeam, teamID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMergedReviewsByUser = `-- name: CountMergedReviewsByUser :one
SELECT COUNT(pr.pr_id)
FROM pull_requests pr
JOIN review_assignments ra ON pr.pr_id = ra.pr_id
WHERE ra.user_id = $1 AND pr.status = 'MERGED'
`

func (q *Queries) CountMergedReviewsByUser(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countMergedReviewsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOpenReviewsByTeam = `-- name: CountOpenReviewsByTeam :one
SELECT COUNT(pr.pr_id)
FROM pull_requests pr
JOIN review_assignments ra ON pr.pr_id = ra.pr_id
JOIN users u ON ra.user_id = u.user_id
WHERE u.team_id = $1 AND pr.status = 'OPEN'
`

func (q *Queries) CountOpenReviewsByTeam(ctx context.Context, teamID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countOpenReviewsByTeam, teamID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOpenReviewsByUser = `-- name: CountOpenReviewsByUser :one
SELECT COUNT(pr.pr_id)
FROM pull_requests pr
JOIN review_assignments ra ON pr.pr_id = ra.pr_id
WHERE ra.user_id = $1 AND pr.status = 'OPEN'
`

func (q *Queries) CountOpenReviewsByUser(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countOpenReviewsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPRs = `-- name: CountPRs :one
SELECT count(*) FROM pull_requests
`

func (q *Queries) CountPRs(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countPRs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPR = `-- name: CreatePR :one
INSERT INTO pull_requests (pr_id, pr_name, author_id)
VALUES ($1, $2, $3)
RETURNING pr_id, pr_name, author_id, status, created_at, merged_at
`

type CreatePRParams struct {
	PrID     string
	PrName   string
	AuthorID string
}

func (q *Queries) CreatePR(ctx context.Context, arg CreatePRParams) (PullRequest, error) {
	row := q.db.QueryRow(ctx, createPR, arg.PrID, arg.PrName, arg.AuthorID)
	var i PullRequest
	err := row.Scan(
		&i.PrID,
		&i.PrName,
		&i.AuthorID,
		&i.Status,
		&i.CreatedAt,
		&i.MergedAt,
	)
	return i, err
}

const findReplacementCandidates = `-- name: FindReplacementCandidates :many
SELECT u.user_id, u.username, u.team_id, u.is_active, u.created_at
FROM users u
WHERE u.team_id = $1      -- Команда, в которой ищем
  AND u.is_active = true    -- Только активные
  AND u.user_id != $2       -- Не автор PR
  AND u.user_id != ALL($3::varchar[]) -- Не те, кто уже назначен
ORDER BY random()
LIMIT $4
`

type FindReplacementCandidatesParams struct {
	TeamID  int32
	UserID  string
	Column3 []string
	Limit   int32
}

func (q *Queries) FindReplacementCandidates(ctx context.Context, arg FindReplacementCandidatesParams) ([]User, error) {
	rows, err := q.db.Query(ctx, findReplacementCandidates,
		arg.TeamID,
		arg.UserID,
		arg.Column3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.TeamID,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuthorTeamByPR = `-- name: GetAuthorTeamByPR :one
SELECT t.team_id, t.team_name, t.is_active
FROM teams t
JOIN users u ON t.team_id = u.team_id
JOIN pull_requests pr ON u.user_id = pr.author_id
WHERE pr.pr_id = $1
`

func (q *Queries) GetAuthorTeamByPR(ctx context.Context, prID string) (Team, error) {
	row := q.db.QueryRow(ctx, getAuthorTeamByPR, prID)
	var i Team
	err := row.Scan(&i.TeamID, &i.TeamName, &i.IsActive)
	return i, err
}

const getOpenPRsWithoutReviewers = `-- name: GetOpenPRsWithoutReviewers :many
SELECT pr.pr_id, pr.pr_name, pr.author_id, pr.status, pr.created_at, pr.merged_at
FROM pull_requests pr
LEFT JOIN review_assignments ra ON pr.pr_id = ra.pr_id
WHERE pr.status = 'OPEN'
GROUP BY pr.pr_id
HAVING COUNT(ra.user_id) = 0
`

func (q *Queries) GetOpenPRsWithoutReviewers(ctx context.Context) ([]PullRequest, error) {
	rows, err := q.db.Query(ctx, getOpenPRsWithoutReviewers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PullRequest
	for rows.Next() {
		var i PullRequest
		if err := rows.Scan(
			&i.PrID,
			&i.PrName,
			&i.AuthorID,
			&i.Status,
			&i.CreatedAt,
			&i.MergedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOpenReviewsForUsers = `-- name: GetOpenReviewsForUsers :many
SELECT ra.pr_id, ra.user_id, pr.author_id
FROM review_assignments ra
JOIN pull_requests pr ON ra.pr_id = pr.pr_id
WHERE pr.status = 'OPEN'
  AND ra.user_id = ANY($1::text[])
`

type GetOpenReviewsForUsersRow struct {
	PrID     string
	UserID   string
	AuthorID string
}

// Находим все ОТКРЫТЫЕ ревью для списка пользователей
func (q *Queries) GetOpenReviewsForUsers(ctx context.Context, dollar_1 []string) ([]GetOpenReviewsForUsersRow, error) {
	rows, err := q.db.Query(ctx, getOpenReviewsForUsers, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOpenReviewsForUsersRow
	for rows.Next() {
		var i GetOpenReviewsForUsersRow
		if err := rows.Scan(&i.PrID, &i.UserID, &i.AuthorID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPRByID = `-- name: GetPRByID :one
SELECT pr_id, pr_name, author_id, status, created_at, merged_at FROM pull_requests
WHERE pr_id = $1
`

func (q *Queries) GetPRByID(ctx context.Context, prID string) (PullRequest, error) {
	row := q.db.QueryRow(ctx, getPRByID, prID)
	var i PullRequest
	err := row.Scan(
		&i.PrID,
		&i.PrName,
		&i.AuthorID,
		&i.Status,
		&i.CreatedAt,
		&i.MergedAt,
	)
	return i, err
}

const getPRsForReviewer = `-- name: GetPRsForReviewer :many
SELECT pr.pr_id, pr.pr_name, pr.author_id, pr.status
FROM pull_requests pr
JOIN review_assignments ra ON pr.pr_id = ra.pr_id
WHERE ra.user_id = $1
`

type GetPRsForReviewerRow struct {
	PrID     string
	PrName   string
	AuthorID string
	Status   PrStatus
}

func (q *Queries) GetPRsForReviewer(ctx context.Context, userID string) ([]GetPRsForReviewerRow, error) {
	rows, err := q.db.Query(ctx, getPRsForReviewer, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPRsForReviewerRow
	for rows.Next() {
		var i GetPRsForReviewerRow
		if err := rows.Scan(
			&i.PrID,
			&i.PrName,
			&i.AuthorID,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewStats = `-- name: GetReviewStats :many
SELECT user_id, COUNT(*) AS review_count
FROM review_assignments
GROUP BY user_id
ORDER BY review_count DESC
`

type GetReviewStatsRow struct {
	UserID      string
	ReviewCount int64
}

func (q *Queries) GetReviewStats(ctx context.Context) ([]GetReviewStatsRow, error) {
	rows, err := q.db.Query(ctx, getReviewStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewStatsRow
	for rows.Next() {
		var i GetReviewStatsRow
		if err := rows.Scan(&i.UserID, &i.ReviewCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewersForPR = `-- name: GetReviewersForPR :many
SELECT u.user_id, u.username, u.team_id, u.is_active, u.created_at
FROM users u
JOIN review_assignments ra ON u.user_id = ra.user_id
WHERE ra.pr_id = $1
`

func (q *Queries) GetReviewersForPR(ctx context.Context, prID string) ([]User, error) {
	rows, err := q.db.Query(ctx, getReviewersForPR, prID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.TeamID,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPRs = `-- name: ListPRs :many
SELECT pr_id, pr_name, author_id, status, created_at, merged_at FROM pull_requests
`

func (q *Queries) ListPRs(ctx context.Context) ([]PullRequest, error) {
	rows, err := q.db.Query(ctx, listPRs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PullRequest
	for rows.Next() {
		var i PullRequest
		if err := rows.Scan(
			&i.PrID,
			&i.PrName,
			&i.AuthorID,
			&i.Status,
			&i.CreatedAt,
			&i.MergedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mergePR = `-- name: MergePR :one
UPDATE pull_requests
SET status = 'MERGED',
    merged_at = NOW()
WHERE pr_id = $1
RETURNING pr_id, pr_name, author_id, status, created_at, merged_at
`

func (q *Queries) MergePR(ctx context.Context, prID string) (PullRequest, error) {
	row := q.db.QueryRow(ctx, mergePR, prID)
	var i PullRequest
	err := row.Scan(
		&i.PrID,
		&i.PrName,
		&i.AuthorID,
		&i.Status,
		&i.CreatedAt,
		&i.MergedAt,
	)
	return i, err
}

const removeAllReviewersFromPR = `-- name: RemoveAllReviewersFromPR :exec
DELETE FROM review_assignments
WHERE pr_id = $1
`

func (q *Queries) RemoveAllReviewersFromPR(ctx context.Context, prID string) error {
	_, err := q.db.Exec(ctx, removeAllReviewersFromPR, prID)
	return err
}

const removeReviewerFromPR = `-- name: RemoveReviewerFromPR :exec
DELETE FROM review_assignments
WHERE pr_id = $1 AND user_id = $2
`

type RemoveReviewerFromPRParams struct {
	PrID   string
	UserID string
}

func (q *Queries) RemoveReviewerFromPR(ctx context.Context, arg RemoveReviewerFromPRParams) error {
	_, err := q.db.Exec(ctx, removeReviewerFromPR, arg.PrID, arg.UserID)
	return err
}
